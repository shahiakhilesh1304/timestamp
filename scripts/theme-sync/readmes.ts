/**
 * Theme README Synchronization
 *
 * Generates and maintains theme documentation:
 * - src/themes/README.md: Primary theme listing table
 * - src/themes/<theme>/README.md: Per-theme documentation
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { dirname, join } from 'path';
import type { ThemeDependency } from '../../src/core/types/index.js';
import type { ThemeId } from '../../src/themes/registry/registry-core.js';
import { THEME_REGISTRY } from '../../src/themes/registry/registry-core.js';

const SITE_URL = 'https://chrisreddington.com/timestamp';

// =============================================================================
// Date Utilities
// =============================================================================

/**
 * Get the next occurrence of New Year's Day.
 */
export function getNextNewYear(): string {
  const now = new Date();
  const currentYear = now.getFullYear();
  const thisNewYear = new Date(currentYear, 0, 1);
  const targetYear = now > thisNewYear ? currentYear + 1 : currentYear;
  return `${targetYear}-01-01T00:00:00`;
}

/**
 * Get the next occurrence of Valentine's Day.
 */
export function getNextValentinesDay(): string {
  const now = new Date();
  const currentYear = now.getFullYear();
  const thisValentines = new Date(currentYear, 1, 14);
  const targetYear = now > thisValentines ? currentYear + 1 : currentYear;
  return `${targetYear}-02-14T00:00:00`;
}

/**
 * Get the next product launch date.
 */
export function getNextProductLaunch(): { date: string; display: string } {
  const now = new Date();
  const currentYear = now.getFullYear();
  const thisLaunch = new Date(Date.UTC(currentYear, 6, 16, 0, 0, 0));
  const targetYear = now > thisLaunch ? currentYear + 1 : currentYear;
  return {
    date: `${targetYear}-07-16T00:00:00Z`,
    display: `July 16, ${targetYear} at 00:00 UTC`,
  };
}

// =============================================================================
// Content Generation
// =============================================================================

/**
 * Generate dependencies section for a theme README.
 */
export function generateDependenciesSection(deps: ThemeDependency[] | undefined): string {
  if (!deps || deps.length === 0) {
    return '';
  }

  const sortedDeps = [...deps].sort((a, b) => a.name.localeCompare(b.name));
  const depList = sortedDeps.map((dep) => `- [${dep.name}](${dep.url})`).join('\n');

  return `## Dependencies

${depList}

`;
}

function generateThemePreviewPicture(themeId: string, themeName: string, basePath?: string): string {
  const lightImg =
    basePath !== undefined
      ? basePath === ''
        ? `${themeId}/images/preview-light.webp`
        : `${basePath}/images/preview-light.webp`
      : './images/preview-light.webp';
  const darkImg =
    basePath !== undefined
      ? basePath === ''
        ? `${themeId}/images/preview-dark.webp`
        : `${basePath}/images/preview-dark.webp`
      : './images/preview-dark.webp';

  return `<picture>
  <source media="(prefers-color-scheme: dark)" srcset="${darkImg}">
  <source media="(prefers-color-scheme: light)" srcset="${lightImg}">
  <img alt="${themeName} theme preview" src="${lightImg}">
</picture>`;
}

function generateThemePreviewForTable(themeId: string, themeName: string): string {
  const darkImg = `${themeId}/images/preview-dark-card-1x.webp#gh-dark-mode-only`;
  const lightImg = `${themeId}/images/preview-light-card-1x.webp#gh-light-mode-only`;
  return `<img src="${darkImg}" alt="${themeName} preview" width="160"><img src="${lightImg}" alt="${themeName} preview" width="160">`;
}

/**
 * Generate the master README for src/themes/README.md.
 */
export function generateMasterReadme(): string {
  const themes = Object.values(THEME_REGISTRY);
  const sortedThemes = themes.sort((a, b) => a.name.localeCompare(b.name));

  const newYear = getNextNewYear();
  const productLaunch = getNextProductLaunch();

  const tableRows = sortedThemes
    .map((theme) => {
      const preview = generateThemePreviewForTable(theme.id, theme.name);
      const worldMap = theme.supportsWorldMap ? '‚úÖ' : '‚ùå';
      const author = theme.author
        ? `[@${theme.author}](https://github.com/${theme.author})`
        : 'Anonymous';

      const localLink = `[üè†](${SITE_URL}?mode=wall-clock&target=${newYear}&theme=${theme.id})`;
      const globalLink = `[üåê](${SITE_URL}?mode=absolute&target=${productLaunch.date}&theme=${theme.id}&message=Launch%20Day!)`;
      const timerLink = `[‚è±Ô∏è](${SITE_URL}?mode=timer&duration=300&theme=${theme.id})`;
      const demoLinks = `${localLink} ${globalLink} ${timerLink}`;

      return `| ${preview} | **${theme.name}** | ${theme.description} | ${worldMap} | ${author} | ${demoLinks} |`;
    })
    .join('\n');

  return `<!-- Auto-generated by scripts/theme-sync/readmes.ts - DO NOT EDIT MANUALLY -->

# Themes

Visual themes for the countdown timer. Each theme provides unique visual aesthetics while maintaining consistent functionality and accessibility.

## Creating New Themes

\`\`\`bash
npm run theme create <theme-name>
\`\`\`

This automatically:
- Creates theme folder structure
- Generates boilerplate code
- Registers theme in \`THEME_REGISTRY\`
- Creates initial test files

See [THEME_DEVELOPMENT.md](../../docs/THEME_DEVELOPMENT.md) for complete guidelines.

## Available Themes

| Preview | Name | Description | World Map | Author | Try It |
|---------|------|-------------|-----------|--------|--------|
${tableRows}

_Total: ${themes.length} themes_ ¬∑ Demo links: üè† Local Time ¬∑ üåê Same Moment ¬∑ ‚è±Ô∏è Timer

## Theme Requirements

Each theme must provide:
- ‚úÖ \`images/preview-*.webp\` - Theme preview images
- ‚úÖ \`TimePageRenderer\` implementation with lifecycle methods
- ‚úÖ Landing page background factory
- ‚úÖ Theme configuration with metadata
- ‚úÖ Accessibility support
- ‚úÖ \`prefers-reduced-motion\` support
- ‚úÖ Responsive layout within safe area bounds
`;
}

/**
 * Generate per-theme README for src/themes/<theme>/README.md.
 */
export function generateThemeReadme(themeId: ThemeId): string {
  const theme = THEME_REGISTRY[themeId];

  const author = theme.author
    ? `[@${theme.author}](https://github.com/${theme.author})`
    : 'Anonymous';
  const worldMapSupport = theme.supportsWorldMap ? 'Yes' : 'No';
  const themeTags = theme.tags ?? [];
  const tags = themeTags.length > 0 ? themeTags.join(', ') : 'None';

  const preview = generateThemePreviewPicture(themeId, theme.name);
  const dependenciesSection = generateDependenciesSection(theme.dependencies);

  const newYear = getNextNewYear();
  const newYearYear = newYear.split('-')[0];
  const valentines = getNextValentinesDay();
  const valentinesYear = valentines.split('-')[0];
  const productLaunch = getNextProductLaunch();

  return `<!-- Auto-generated by scripts/theme-sync/readmes.ts - DO NOT EDIT MANUALLY -->

# ${theme.name}

> ${theme.description}

${preview}

## Metadata

| Property | Value |
|----------|-------|
| **Theme ID** | \`${theme.id}\` |
| **Published** | ${theme.publishedDate} |
| **Author** | ${author} |
| **World Map Support** | ${worldMapSupport} |
| **Tags** | ${tags} |

${dependenciesSection}## Quick Demo Links

Try this theme with different countdown modes:

### üè† Local Time ‚Äî *Wall clock* (Per timezone)
- [New Year ${newYearYear}](${SITE_URL}?mode=wall-clock&target=${newYear}&theme=${theme.id})
- [Valentine's Day ${valentinesYear}](${SITE_URL}?mode=wall-clock&target=${valentines}&theme=${theme.id})

### üåê Same Moment ‚Äî *Absolute time* (One instant globally)
- [Product Launch (${productLaunch.display})](${SITE_URL}?mode=absolute&target=${productLaunch.date}&theme=${theme.id}&message=Launch%20Day!)

### ‚è±Ô∏è Timer ‚Äî *Your countdown* (Fixed duration)
- [5 Minute Timer](${SITE_URL}?mode=timer&duration=300&theme=${theme.id})
- [30 Second Demo](${SITE_URL}?mode=timer&duration=30&theme=${theme.id})

## Related Documentation

- [Theme Development Guide](../../docs/THEME_DEVELOPMENT.md)
- [Deep Linking Reference](../../docs/DEEP-LINKING.md)
- [Project README](../../README.md)
`;
}

// =============================================================================
// File Operations
// =============================================================================

function writeMasterReadme(): void {
  const filePath = join(process.cwd(), 'src/themes/README.md');
  const content = generateMasterReadme();

  const dir = dirname(filePath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  writeFileSync(filePath, content, 'utf-8');
  console.log('‚úÖ Generated src/themes/README.md');
}

function writeThemeReadmes(): void {
  const themeIds = Object.keys(THEME_REGISTRY) as ThemeId[];

  for (const themeId of themeIds) {
    const filePath = join(process.cwd(), `src/themes/${themeId}/README.md`);
    const content = generateThemeReadme(themeId);

    const dir = dirname(filePath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    writeFileSync(filePath, content, 'utf-8');
    console.log(`‚úÖ Generated src/themes/${themeId}/README.md`);
  }
}

function checkReadmeSync(): boolean {
  let allMatch = true;

  const masterPath = join(process.cwd(), 'src/themes/README.md');
  if (!existsSync(masterPath)) {
    console.error('‚ùå Missing: src/themes/README.md');
    allMatch = false;
  } else {
    const expectedMaster = generateMasterReadme();
    const actualMaster = readFileSync(masterPath, 'utf-8');
    if (expectedMaster !== actualMaster) {
      console.error('‚ùå Out of sync: src/themes/README.md');
      allMatch = false;
    }
  }

  const themeIds = Object.keys(THEME_REGISTRY) as ThemeId[];
  for (const themeId of themeIds) {
    const themePath = join(process.cwd(), `src/themes/${themeId}/README.md`);
    if (!existsSync(themePath)) {
      console.error(`‚ùå Missing: src/themes/${themeId}/README.md`);
      allMatch = false;
    } else {
      const expectedTheme = generateThemeReadme(themeId);
      const actualTheme = readFileSync(themePath, 'utf-8');
      if (expectedTheme !== actualTheme) {
        console.error(`‚ùå Out of sync: src/themes/${themeId}/README.md`);
        allMatch = false;
      }
    }
  }

  return allMatch;
}

// =============================================================================
// Exports
// =============================================================================

/**
 * Sync READMEs from registry.
 *
 * @returns true if successful
 */
export function syncReadmes(): boolean {
  try {
    const themeCount = Object.keys(THEME_REGISTRY).length;
    console.log(`üìã Found ${themeCount} themes in THEME_REGISTRY`);
    writeMasterReadme();
    writeThemeReadmes();
    console.log(`\n‚úÖ Generated ${themeCount + 1} README files`);
    return true;
  } catch (error) {
    console.error('‚ùå Failed to sync READMEs:', error);
    return false;
  }
}

/**
 * Check if READMEs are in sync with registry.
 *
 * @returns true if in sync, false otherwise
 */
export function checkReadmesSync(): boolean {
  const inSync = checkReadmeSync();
  if (inSync) {
    console.log('‚úÖ All theme READMEs are in sync with THEME_REGISTRY');
    return true;
  }

  console.error('‚ùå Theme READMEs are out of sync with THEME_REGISTRY');
  console.error('   Run: npm run theme sync:readmes');
  return false;
}
